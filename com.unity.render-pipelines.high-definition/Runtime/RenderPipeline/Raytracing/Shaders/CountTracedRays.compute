// Shader by @ionut.


#pragma kernel CS_CountRays

#pragma only_renderers d3d11

RWTexture2D<float4> _RayCountTexture;
RWTexture2D<uint> _TotalRaysTex;

groupshared uint rayCountPerThreadGroup;

[numthreads(8,8,1)]
void CS_CountRays(uint3 globalId : SV_DispatchThreadID, uint3 localId : SV_GroupThreadID)
{
    // CS_CountRays reads from a texture holding ray count per pixel
    // and sums first across all pixels in a threadgroup,
    // and then across all threadgroups. Barriers are used to prevent contention.

	if (localId.x == 0 && localId.y == 0)
		rayCountPerThreadGroup = 0;
		
    GroupMemoryBarrierWithGroupSync();
	
	const uint rayCount = _RayCountTexture[globalId.xy].x;
	
	InterlockedAdd(rayCountPerThreadGroup, rayCount);
	
    GroupMemoryBarrierWithGroupSync();
		
	if (localId.x == 0 && localId.y == 0)
		InterlockedAdd(_TotalRaysTex[uint2(0, 0)], rayCountPerThreadGroup);
}

#pragma kernel CS_ClearTotal

#pragma only_renderers d3d11

[numthreads(1, 1, 1)]
void CS_ClearTotal(uint3 globalId : SV_DispatchThreadID)
{
    // Since the total must be stored in a texture
    // to allow random writes, it must be cleared as a
    // texture. 
    _TotalRaysTex[uint2(0, 0)] = 0;
}

#pragma kernel CS_Clear

#pragma only_renderers d3d11

[numthreads(8, 8, 1)]
void CS_Clear(uint3 globalId : SV_DispatchThreadID, uint3 localId : SV_GroupThreadID)
{
    // Since the total must be stored in a texture
    // to allow random writes, it must be cleared as a
    // texture. 
    _RayCountTexture[globalId.xy] = 0;
}

#pragma kernel CS_GetMegaRaysPerFrameTexture

#pragma only_renderers d3d11

// Async readback supports only float textures
RWTexture2D<float> _MegaRaysPerFrameTexture;

[numthreads(1, 1, 1)]
void CS_GetMegaRaysPerFrameTexture(uint3 globalId : SV_DispatchThreadID)
{
    // Converts to megarays. Output is a float in order to use AsyncGPUReadbackRequest to get the value back to the CPU
    // to write to a text object. 
    if (globalId.x == 0 && globalId.y == 0)
        _MegaRaysPerFrameTexture[uint2(0, 0)] = (float)_TotalRaysTex[uint2(0, 0)] / (1000.0f * 1000.0f);
}
//
//#pragma kernel CS_GetMegaRaysPerFrame
//#pragma only_renderers d3d11
//int _MegaRaysPerFrame;
//[numthreads(1, 1, 1)]
//void CS_GetMegaRaysPerFrame(uint3 globalId : SV_DispatchThreadID)
//{
//    // Converts to megarays. Output is a float in order to use AsyncGPUReadbackRequest to get the value back to the CPU
//    // to write to a text object. 
//    if (globalId.x == 0 && globalId.y == 0)
//        _MegaRaysPerFrame = (float)_TotalRaysTex[uint2(0, 0)] / (1000.0f * 1000.0f);
//}
