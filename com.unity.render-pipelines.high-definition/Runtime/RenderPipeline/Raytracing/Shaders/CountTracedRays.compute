// Shader by @ionut.


#pragma kernel CS_CountRays

#pragma only_renderers d3d11

RWTexture2D<uint4> _RayCountTexture;
// Interlocked add can only operate on scalar values,
// so allocate separate uint textures.
RWTexture2D<uint> _TotalAORaysTex;
RWTexture2D<uint> _TotalReflectionRaysTex;
RWTexture2D<uint> _TotalAreaShadowRaysTex;

groupshared uint aoRayCountPerThreadGroup;
groupshared uint reflectionRayCountPerThreadGroup;
groupshared uint areaShadowRayCountPerThreadGroup;

[numthreads(8,8,1)]
void CS_CountRays(uint3 globalId : SV_DispatchThreadID, uint3 localId : SV_GroupThreadID)
{
    // CS_CountRays reads from a texture holding ray count per pixel
    // and sums first across all pixels in a threadgroup,
    // and then across all threadgroups. Barriers are used to prevent contention.

    if (localId.x == 0 && localId.y == 0)
    {
        aoRayCountPerThreadGroup = 0;
        reflectionRayCountPerThreadGroup = 0;
        areaShadowRayCountPerThreadGroup = 0;
    }
		
    GroupMemoryBarrierWithGroupSync();
	
    const uint aoRayCount           = (uint)_RayCountTexture[globalId.xy].x;
    const uint reflectionRayCount   = (uint)_RayCountTexture[globalId.xy].y;
    const uint areaShadowRayCount   = (uint)_RayCountTexture[globalId.xy].z;
	
    InterlockedAdd(aoRayCountPerThreadGroup,            aoRayCount);
    InterlockedAdd(reflectionRayCountPerThreadGroup,    reflectionRayCount);
    InterlockedAdd(areaShadowRayCountPerThreadGroup,    areaShadowRayCount);
	
    GroupMemoryBarrierWithGroupSync();
		
    if (localId.x == 0 && localId.y == 0)
    {
        InterlockedAdd(_TotalAORaysTex[uint2(0, 0)].x, aoRayCountPerThreadGroup);
        InterlockedAdd(_TotalReflectionRaysTex[uint2(0, 0)].x, reflectionRayCountPerThreadGroup);
        InterlockedAdd(_TotalAreaShadowRaysTex[uint2(0, 0)].x, areaShadowRayCountPerThreadGroup);
    }
}

#pragma kernel CS_ClearTotal

#pragma only_renderers d3d11

[numthreads(1, 1, 1)]
void CS_ClearTotal(uint3 globalId : SV_DispatchThreadID)
{
    // Since the total must be stored in a texture
    // to allow random writes, it must be cleared as a
    // texture. 
    _TotalAORaysTex[uint2(0, 0)] = 0;
    _TotalReflectionRaysTex[uint2(0, 0)] = 0;
    _TotalAreaShadowRaysTex[uint2(0, 0)] = 0;
}

#pragma kernel CS_Clear

#pragma only_renderers d3d11

[numthreads(8, 8, 1)]
void CS_Clear(uint3 globalId : SV_DispatchThreadID, uint3 localId : SV_GroupThreadID)
{
    // Since the total must be stored in a texture
    // to allow random writes, it must be cleared as a
    // texture. 
    _RayCountTexture[globalId.xy] = uint4(0.0, 0.0, 0.0, 0.0);
}

#pragma kernel CS_GetMegaRaysPerFrameTexture

#pragma only_renderers d3d11

// Async readback supports only float textures
RWTexture2D<float4> _MegaRaysPerFrameTexture;

[numthreads(1, 1, 1)]
void CS_GetMegaRaysPerFrameTexture(uint3 globalId : SV_DispatchThreadID)
{
    // Converts to megarays. Output is a float in order to use AsyncGPUReadbackRequest to get the value back to the CPU
    // to write to a text object. 
    if (globalId.x == 0 && globalId.y == 0)
    {
        float aoInMRays = (float)_TotalAORaysTex[uint2(0, 0)].x / (1000.0f * 1000.0f);
        float reflectionInMRays = (float)_TotalReflectionRaysTex[uint2(0, 0)].x / (1000.0f * 1000.0f);
        float areaShadowInMRays = (float)_TotalAreaShadowRaysTex[uint2(0, 0)].x / (1000.0f * 1000.0f);
        _MegaRaysPerFrameTexture[uint2(0, 0)] = float4(aoInMRays, reflectionInMRays, areaShadowInMRays, aoInMRays + reflectionInMRays + areaShadowInMRays);
    }
}
